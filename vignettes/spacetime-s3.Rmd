---
title: "The spacetime s3 class"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The spacetime s3 class}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(sfdep)
library(dplyr)
```

sfdep introduces a new s3 class to represent spatio-temporal data. The `spacetime` class links a flat data set containing spatio-temporal information with the related geometry. The spacetime class is informed by the `{spacetime}` package by Edzer Pebesma (2012), and the interface is inspired by the design of `{tidygraph}`.

## Spatio-temporal data

Traditionally "spatio-temporal data often come in the form of single tables" that can typically be categorized as "time-wide", "space-wide", or "long formats." In long formats, often referred to as "tidy", a row identifies a unique location and time observation represented by a column dedicated to time and another to locations. This is the typical presentation of panel data.

Space-wide data present each time period across each row and locational information in each column. Whereas a time-wide representation has location data down the rows and each time period is represented as a new column.

These flat formats are not linked to the geographies that they represent in any meaningful way. These flat files typically contain only an identifier of the location, but the spatial representation.

The `spacetime` class is developed with particular focus to lattice data. That is, to create a representation of spatio-temoral data for a set of regions over a number of different time-periods e.g. population densities in census tracts for each year.

To represent spatial data in a temporal context Pebesma, 2012 identifies a number of spatio-temporal layouts, two of which are of particular interest. These are the spatio-temporal full grid and sparse grids.

Given a number of spatial features $n$, and time periods $m$, a *spatio-temporal full grid* contains $n \times m$ rows. Each location has a recorded observation for each of the time periods in $m$. For example, if there are 10 locations and 20 time periods, there are 20 observations per location meaning there are $10 \times 20 = 200$ observations. This is efficient only when are there are complete time-series for each location.

When there are missing observations for some locations or time periods and they are entirely omitted from the data set, that is a *spatio-temporal sparse grid*. In this case $N \lt m \times n$

## spacetime s3 class in sfdep

Inspired by the design of the tidygraph package, the spacetime class links a data frame and an sf object based on a shared location identifier column. These are referred to as the *data context* and the *geometry context*. The spacetime class allows you switch between different contexts and work with them individually as you see fit.

Typically, if one wants to represent location data over multiple time periods containing information about the geography, an sf object is used which duplicates the geometry at each location for each time period which can be computationally expensive. By linking sf objects to a data frame based on their location ID, we are able to avoid this problem

There are four important aspects to the spacetime class:

-   the data: a `data.frame` object
-   the geometry: an `sf` object
-   the location identifiers
-   the time column

### Creating a spacetime object

There are two ways to create spacetime objects: 1) with `as_spacetime()` and 2) `spacetime()` or `new_spacetime()`. The former takes an sf object that contains the location IDs, times, and geometry and converts it into a spacetime object. Whereas the constructor functions require a data frame and a separate sf object containing the geometry.

Let's create a sample data set using the `guerry`

```{r}
# replicate the guerry dataset 10 times
x <- purrr::map_dfr(1:10, ~guerry) |> 
  select(code_dept, crime_pers) |> 
         # create an indicator for time period
  mutate(time_period = sort(rep(1:10, 85)), 
         # add some noise 
         crime_pers = crime_pers * runif(850, max = 2))

x
```

This representation, where there are duplicate geometries for each location, should be cast into a spacetime object using `as_spacetime()`.

```{r}
spt <- as_spacetime(x, "code_dept", "time_period")
```

Alternatively, we have the other scenario, 



## Spacetime Contexts

The **data context**

```{r}
activate(spt, "data")
```

The **geometry** context

```{r}
spt |> 
  activate("geometry") 
```

-   The spacetime cube as made popular by ESRI is a spatio-temporal full grid (Pebesma, 2012)

    -   when setting columns from geometry context to data context follows this advice "for each moment in time, the same set of spatial entities is sampled." (Pebesma, 2012)

-   "Unsampled combinations of (space, time) are stored in this class, but are assigned a missing value NA." (Pebesma, 2012)

    -   If data is represented in a "spatio-temporal sparse grid" it can be made into a full grid using `complete_spacetime_cube()`

â€š
